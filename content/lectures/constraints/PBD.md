---
title: 3. PBD
author: Роман Козак
type: docs
math: true
toc: true
sidebar:
  open: true
---
{{< add_script "js/constraints/elastic_inelastic.js" >}}


## Интро



## PBD 

Это первая статья в серии XPBD. Она является логичным продолжением метода hitman. Была написана в далеком 2006. Зацените видос [Position Based Dynamics](https://www.youtube.com/watch?v=j5igW5-h4ZM)

### Интегратор

Первое улучшение -- это использование другого интегратора.
В прошлом методе было сложно добиться хороших и сочных упругих коллизий. В основном мы получали неупругое столкновение, из-за того что не могли управлять скоростью
В PBD Вместо Vanilla Euler используется Symplectic Euler.
Напомню, что Symplectic Euler выглядит так:

$$
\begin{equation}
\begin{split}
v_{i+1} = v_i + \Delta t \cdot a_i
x_{i+1} = x_i + \Delta t \cdot v_{i+1}
\end{split}
\end{equation}
$$

В этом интеграторе есть скорость в явном виде. И это позволяет без всяких костылей управлять скоростью. Поэтому можно просто сделать вот такое упругое столкновение.

{{< include_sketch path="constraints/sketch/elastic_inelastic_sketch.js" base_name="elastic_inelastic_sketch" >}}


### Универсальное решение
В статье Hitman авторы придумывали разные методы для разрешения ограничений. И математического обоснование под это не было. Они действовали скорее интуитивно. 
В PBD предлагают универсальное решение по тому как лучше всего разрешать ограничения $C(\vec{p})$.


Для того чтобы разрешить уравнение нужно найти такое $\Delta \vec{p}$, чтобы $C(\vec{p} + \Delta \vec{p}) = 0$. Здесь $\vec{p}$ -- конкатенация всех позиций всех точек. Те если у нас есть два шарика, то $\vec{p} = [x_1, y_1, x_2, y_2]$.

Для произвольного ограничения мы не можем так просто его найти, поэтому делают стандартное разложение в ряд Тейлора и оставляют только первые два члена.

$$
\begin{equation}
C(\vec{p} + \Delta \vec{p}) \approx C(\vec{p}) + \nabla_{\vec{p}} C(\vec{p}) \cdot \Delta \vec{p} = 0
\end{equation}
$$

Если бы это было обычное уравнение, то мы бы его запросто решил. Но тут векторы и получается проблемка. Предположим, что $C(\vec{p}) = c$ и $\nabla_{\vec{p}} C(\vec{p}) = [a, b]$ и $\Delta \vec{p} = [x, y]$. Тогда у нас получится такое уравнение:

$$
a * x + b * y = -c
$$

{{< image path="images/constraints/pbd/straight.excalidraw.png" >}}

Собственно это уравнение прямой. Для того чтобы найти однозначное решение, нужно добавить еще одно ограничение.  
В качестве него мы можем требовать чтобы $\Delta \vec{p}$ была сонаправлена с градиентом.  Т.е $\Delta \vec{p} = \lambda \nabla_p C(\vec{p})$.

Почему так, можно понять на простом примере. Вот у нас есть маятник. Он должен сохранять расстояние до подвеса.
И мы пытаемся найти новую позицию для шарика. Самое логичное решение -- это двигать шарик по самому короткому пути к второму шарику. Т.е по направлению градиента.

{{< image path="images/constraints/pbd/stretch_grad.excalidraw.png" >}}

С дополнительным уравнением можно получить решение 
$$
\begin{equation}
\Delta \vec{p} = -\frac{C(\vec{p})}{\nabla_p C(\vec{\vec{p}}) \cdot \nabla_p C(\vec{p})} \nabla_p C(\vec{p})
\end{equation}
$$

Для того чтобы было удобнее считать, нужно разбить $\vec{p}$ на $\vec{p_1}, \dots, \vec{p_n}$, можно переписать решение для конкретной $\vec{p_i}$ и разрешить ограничение вида $C(\vec{p_1}, \dots, \vec{p_n})$ нужно переписать уравнение вот так:

$$
\begin{equation}
\begin{split}
&\Delta \vec{p_i} = -s * \nabla_{\vec{p_i}} C \\\
&s = \frac{C}{\sum_{k} (\nabla_{\vec{p_k}} C)^2}
\end{split}
\end{equation}
$$

#### Пытаемся понять
Расчет $\Delta \vec{p}$ состоит из двух частей. 
Первая часть -- это градиент ограничения:
 $-\nabla_{\vec{p_i}} C(\vec{p})$ -- Это вектор, который показывает в какую сторону нужно двигаться чтобы уменьшить ограничение. 
Собственно, это то что я показывал на прошлом рисунке. 

Вторая часть -- это коэффициент $s$. Он показывает насколько сильно нужно двигаться в этом направлении. Знаменатель в нем означает, что чем больше точек участвует в ограничении, тем меньше нужно двигаться каждой точке.

Давайте на примере. Вот у нас есть ограничение на площадь десятиугольника. $C(\vec{p_1}, \dots, \vec{p_{10}}) = S - S_0$.

{{< image path="images/constraints/pbd/v_conserv.excalidraw.png" >}}

И давайте предположим, что эту фигуру равномерно сжало. 
Нужно восстановить площадь. Этого можно добиться несколькими способами: Например, подвинуть одну точку очень сильно, а остальные вообще не двигать. Или можно подвинуть все точки немного. Если у точек одинаковая масса, то второй вариант просто логичнее.

{{< image path="images/constraints/pbd/v_scale.excalidraw.png" >}}

Собственно вот этот множитель $s$ и позволяет нам делать это. Мы сдвигаем все точки на одинаковое расстояние.

#### Добавляем массу
Как и в прошлом методе, хочется, чтобы точка потяжелее двигалась меньше при разрешении ограничения. 
Дальше тк мы постоянно делим на массу в уравнениях очень часто будет встречаться понятие инвертированной массы. $w = \frac{1}{m}$. Инвертированной массой очень просто определять несдвигаемые точки -- точку с бесконечной массой. Для нее $w = 0$.

Для того чтобы учесть инвертированную массу прошлое уравнение $\Delta \vec{p} = \lambda \nabla_p C(\vec{p})$  скалируют на инвертированную массу и получают вот такое уравнение:
$\Delta \vec{p} = -s * \nabla_{\vec{p_i}} C * w_i$

{{< image path="images/constraints/pbd/mass_delta.excalidraw.png" >}}

Если его разрешить, то получится вот такие уравнения:
$$
\begin{equation}
\begin{split}
&\Delta \vec{p_i} = -s * w_i * \nabla_{\vec{p_i}} C \\\
&s = \frac{C}{\sum_{k} (w_k * \nabla_{\vec{p_k}} C)^2}
\end{split}
\end{equation}
$$

Обратите внимание, что теперь в знаменателе стоит $w_k * \nabla_{\vec{p_k}} C$.

Вот собственно и рецепт разрешения ограничений в PBD.

#### Неравенства 

Ограничения могут быть в виде неравенств. Как и в прошлом методе. Их переводят в ограничение равенства и разрешают его только если оно нарушено.

{{< image path="images/constraints/pbd/collision_static.excalidraw.png" >}}

Например коллизия для точки со статическим объектом описывается вот таким ограничением:
$$
C(\vec{p_1}) = \vec{p_1}\cdot \vec{n} \leq 0
$$

И разрешать мы будем только если оно уже нарушилось в виде 
$$
\begin{equation}
C(\vec{p_1}) = \vec{p_1}\cdot \vec{n} = 0
\end{equation}
$$

### Коллизии

Коллизии в PBD разрешаются в несколько этапов. 

1. Первый этап -- поиск коллизий.
2. Второй этап -- разрешение коллизий по позициям.
3. Третий этап -- разрешение коллизий по скоростям (трение и упругость)

#### Поиск коллизий

Тк алгоритм поиска коллизий достаточно медленный, то он запускается один раз перед разрешением всех ограничений.
Это приводит к тому, что при разрешении всех ограничений, может возникнуть новая коллизия.  

Вот например ситуация 

{{< image path="images/constraints/pbd/collisions_bad.excalidraw.png" >}}

Палочка врезается в стену. Мы фиксируем коллизию. И разрешаем ее. Потом мы восстанавливаем длину палочки и после этого другая точка палочки врезается в стену. 

Авторы никак не решают эту проблему. На практике она не сильно заметна для пользователя, тк на следующей итерации физика все равно исправит эту коллизию.

#### Разрешение коллизий по позициям

Как колизится со статической плоскостью описал выше.
Теперь нужно разобраться как разрешать коллизии между двумя динамическими объектами.

Сначала в 2D. Вот шарик летит в систему шариков. 

Если он попал в связь между шариками, то наша задача выдавить шарик в правильную полуплоскости.

{{< image path="images/constraints/pbd/collision_dynamic.excalidraw.png" >}}

Ограничение коллизии между шариком $\vec{p_1}$ и линией образованной двумя другими шариками $\vec{p_2}$ и $\vec{p_3}$ можно описать вот так:

$$
\begin{equation}
\begin{split}
&\vec{m_p} = \vec{p_1} + \frac{(\vec{p_2} - \vec{p_1}) \cdot (\vec{p_3} - \vec{p_1})}{||\vec{p_2} - \vec{p_1}||^2} \cdot (\vec{p_2} - \vec{p_1}) \\\
&\vec{d} = \vec{m_p} - \vec{p_1} \\\
&C(\vec{p_1}, \vec{p_2}, \vec{p_3}) = ||\vec{d}|| = 0
\end{split}
\end{equation}
$$

Это просто расстояние от точки до прямой. 
Если есть какой-то радиус у точки, то нужно учитывать полуплоскость в которую нужно выдавить точку. От этого зависит знак в ограничении.
$$
\begin{equation}
C(\vec{p_1}, \vec{p_2}, \vec{p_3}) = \pm ||\vec{d}|| - R = 0
\end{equation}
$$

Теперь в 3d. 

Идея та же самая, просто вместо прямой у нас плоскость из трех точек.

{{< image path="images/constraints/pbd/collision_dynamic_3d.excalidraw.png" >}}

Мы должны держать точку 1 на расстоянии $R$ от плоскости образованной точками 2, 3 и 4.
Ограничение будет вот таким:
$$
\begin{equation}
\begin{split}
&\vec{n} = [(\vec{p_3} − \vec{p_2}) \times (\vec{p_4} − \vec{p_2})] \\\
&C(\vec{p_1},\vec{p_2},\vec{p_3},\vec{p_4}) = \pm (\vec{p_1}−\vec{p_2}) \cdot \vec{n} - R = 0 
\end{split}
\end{equation}
$$

#### Разрешение коллизий по скоростям

Для того чтобы было ощущение столкновения, нужно правильно изменить скорости точек. 

Для точки и мягкого тела это можно сделать просто. 

## Источники

- Оригинальная статья [Position Based Dynamics](https://matthias-research.github.io/pages/publications/posBasedDyn.pdf)
- Хороший видос с объяснением [Position Based Dynamics](https://www.youtube.com/watch?v=fH3VW9SaQ_c)
