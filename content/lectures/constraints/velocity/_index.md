---
title: 3. Скоростные ограничения
author: Роман Козак
type: docs
weight: 3
math: true
toc: true
sidebar:
  open: true
---


## Интро

{{< add_script "js/constraints/sequential_impulses.js" >}}
{{< add_script "js/constraints/impulses_cube.js" >}}

В предыдущих методах мы решали ограничения с помощью манипуляций позиций и поворотов тел.
Он отлично работает для симуляции мягких тел, волос, тканей и прочего. Наиболее успещный метод среди позиционных -- XPBD.
Но у него есть недостаток: он дает несовсем правильные скорости тел. Для того чтобы получить скорости мы делали много вещей -- вычисляли скорость из старой позиции и исправленной. Дополнительно пытались учесть трение и отталкивание.

Поэтому умные ребята придумали другой способ разрешать ограничения.

Основная идея такая: Давайте посмотрим как бы мы разрешали коллизии для шариков. Мы бы просто выставили скорость шарика так, чтобы при столкновении мы получали отражение. 

{{<details title="Решение столкновения шариков" closed="true">}}

#### 1. Дано:
- Массы сфер: $m_1$ и $m_2$
- Скорости сфер до столкновения: $\vec{v_1}$ и $\vec{v_2}$
- Радиусы сфер: $r_1$ и $r_2$
- Коэффициент упругости $e$, где $e = 1$ для абсолютно упругого столкновения и $e < 1$ для частично упругого.
- Положение центров сфер до удара: $\vec{r_1}$ и $\vec{r_2}$

#### 2. Расчёт нормальной составляющей скорости:

Сначала находим нормальный вектор столкновения, который направлен вдоль линии, соединяющей центры двух сфер:

\begin{equation}
\hat{n} = \frac{\vec{r_2} - \vec{r_1}}{|\vec{r_2} - \vec{r_1}|}
\end{equation}

Касательный вектор $\hat{t}$ будет перпендикулярен $\hat{n}$, но для нас важна только нормальная составляющая при упругом столкновении.

#### 3. Проекция скоростей на нормальный вектор:

Теперь проектируем скорости сфер на нормальный вектор:

\begin{equation}
\begin{split}
&v_{1n} = \vec{v_1} \cdot \hat{n} \\
&v_{2n} = \vec{v_2} \cdot \hat{n}
\end{split}
\end{equation}

Эти проекции — скорости сфер вдоль линии столкновения.

#### 4. Закон сохранения импульса:

При упругом столкновении сохраняется и импульс, и кинетическая энергия. Для нормальных составляющих скоростей:

\begin{equation}
m_1 v_{1n} + m_2 v_{2n} = m_1 v'_{1n} + m_2 v'_{2n}
\end{equation}

где $v'_{1n}$ и $v'_{2n}$ — нормальные компоненты скоростей после удара.

#### 5. Закон коэффициента упругости:

Коэффициент упругости $e$ описывает, насколько изменится относительная скорость сфер после удара по сравнению с до удара:

\begin{equation}
e = \frac{v'_{2n} - v'_{1n}}{v_{1n} - v_{2n}}
\end{equation}

Для абсолютно упругого удара, где $e = 1$, это становится:

\begin{equation}
v'_{2n} - v'_{1n} = v_{1n} - v_{2n}
\end{equation}

#### 6. Решение системы уравнений:

Теперь у нас есть два уравнения:

1. $m_1 v_{1n} + m_2 v_{2n} = m_1 v'_{1n} + m_2 v'_{2n}$
2. $v'_{2n} - v'_{1n} = v_{1n} - v_{2n}$

Решив их, получаем нормальные компоненты скоростей после удара:

\begin{equation}
\begin{split}
&v'_{1n} = \frac{(m_1 - e m_2) v_{1n} + (1 + e) m_2 v_{2n}}{m_1 + m_2} \\
&v'_{2n} = \frac{(m_2 - e m_1) v_{2n} + (1 + e) m_1 v_{1n}}{m_1 + m_2}
\end{split}
\end{equation}

#### 7. Скорости после удара:

После того как мы нашли нормальные составляющие скоростей $v'_{1n}$ и $v'_{2n}$, можем вычислить итоговые скорости сфер:

\begin{equation}
\begin{split}
&\vec{v'_1} = \vec{v_1} + (v'_{1n} - v_{1n}) \hat{n} \\
&\vec{v'_2} = \vec{v_2} + (v'_{2n} - v_{2n}) \hat{n}
\end{split}
\end{equation}

Теперь у нас есть итоговые скорости сфер после столкновения.

{{</details>}}


{{< include_sketch path="constraints/sketch/balls_impulse_sketch.js" base_name="balls_impulse_sketch" >}}






Вот у нас есть какое-то ограничение зависящее от позиции

$$
C(x) = 0
$$

Если продифференцировать это ограничение по времени, то получим скорость точки в направлении ограничения.

$$
\dot{C}(x) = \frac{dC}{dx} \cdot \dot{x}
$$

Теперь мы можем использовать это уравнение для того чтобы изменить скорость точки так, чтобы она удовлетворяла ограничению.
Если мы в каждый момент времени будет выставлять скорость точки правильным образом, то оригинальное ограничение будет удовлетворено.

### Пример

Рассмотрим ситуацию, когда обычный кубик падает на пол и касается одной точкой пола.

{{< image path="images/constraints/sequential_impulses/cube_on_ground_1.excalidraw.png" >}}
В этом случае у нас есть ограничение на позицию кубика относительно пола. Его точка соприкосновения должна находиться выше уровня пола.
$$
C(x) = x\cdot n - h = 0
$$

Где $n$ -- нормаль к поверхности пола, $h$ -- высота пола.
Если продифференцировать это ограничение по времени, то получим скорость точки в направлении ограничения.
$$
\dot{C}(x) = n \cdot \dot{x}
$$
Теперь мы можем использовать это уравнение для того чтобы изменить скорость точки так, чтобы она удовлетворяла ограничению.

Пробуем:

{{< include_sketch path="constraints/sketch/impulses_cube_sketch.js" base_name="impulses_cube_sketch" >}}





Пусть это будет ограничения на дистанцию точки от подвеса.

$$
C(x) = \|x - x_0\|^2 - r^2 = 0
$$

Если продифференцировать это ограничение по времени, то получим скорость точки в направлении ограничения.

$$
\dot{C}(x) = 2(x - x_0) \cdot \dot{x} = 0
$$

Для нас это означает, что проекция скорости точки на вектор от точки до подвеса должна быть равна нулю.

$$
v_{\parallel} = (x - x_0) \cdot \dot{x} = 0
$$

Или, что скорость точки должна быть перпендикулярна вектору от точки до подвеса.

{{< image path="images/constraints/sequential_impulses/pendulum_velocity.excalidraw.png" >}}

Если скорость всегда будет перпендикулярна вектору от точки до подвеса, то ограничение на дистанцию будет удовлетворено.

Симулируем...
{{< include_sketch path="constraints/sketch/impulses_pendulum.js" base_name="impulses_pendulum" >}}

И ничего не получилось. Это происхожит потому что мы не можем изменять скорость непрерывно. Мы делаем это дискретно, появляется ошибка и она накапливается.

##  Baumgarte Stabilization

У нас появилась дополнительная задача -- помимо удовлетворения ограничения, нам нужно еще и следить за тем, чтобы ошибка не накапливалась.
Для этого мы можем использовать метод Баумгартена.
Если изначально мы пытались удовлетворить производной ограничения $$\dot{C}(x) = 0$$, то теперь мы будем пытаться удовлетворить ограничение с некоторым запасом чтобы убирать накопившуюся ошибку.

$$
\dot{C}(x) + \lambda \cdot C(x) = 0
$$

Где $\lambda$ -- это некоторый коэффициент, который мы можем менять. Чем больше $\lambda$, тем быстрее ошибка будет сходить на нет.

Давайте сразу просимулируем двойной маятник.

{{< include_sketch path="constraints/sketch/baumgarte_double_impulses.js" base_name="baumgarte_double_impulses" >}}

Если $\lambda$ слишком большой, то при большой ошибке, мы можем получить слишком большую скорость. Это особенно хорошо заметно в симуляциях с коллизиями, когда один объект глубоко проникает в другой. То он вылетает с большой скоростью.

Такой подход использовался в старой версии Box2D, но потом его убрали. 

В Движке ODE это называется ERP (ERP - Error Reduction Parameter)
[Пуньк](<https://ode.org/wiki/index.php/Manual#Soft_constraint_and_Constraint_Force_Mixing_(CFM)>)

## NGS 